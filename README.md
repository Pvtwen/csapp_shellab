# 具体函数
- eval函数对用户数输入的命令行解析，builtcommand函数分析用户输入的命令是否是系统内置命令，比如quit。

# 接收信号
- 在子进程结束任务后，会变成一个僵死进程，但是依然会存在于内存中，这时操作系统内核会发出一个SIGCHLD信号给shell主进程，如果在shell脚本中不对SIGCHLD信号进行重新定义，那么shell进程会选择忽略。所以会在shell中定义一个sigchld_handler函数对SIGCHLD信号进行处理
# joblist
- 所有的进程都是存储在jobList中，包括进程号，进程的状态(前台进程还是后台进程)
# 具体功能
- 查看shell中所有的进程信息
- 通过cz ctrlc可以结束任务和挂起任务 
- 可以将一个进程选择性地挂到前台或者是后台
- 选择将一个进程前台启动还是后台启动
# 注意
- shell主进程必须与子进程拥有不同的进程组号，因为ctrlc很有可能会将shell和子进程一块终止。
- 在创建子进程前后必须加上sigprocmask屏蔽sigchld信号，否则会导致竞争现象（先执行delete后执行add)，这样子进程一直不会被删除
# 讲述
- 主要实现了中断，挂起前台进程，查询所有进程的信息，以及将后台的任意一个子进程(可以是挂起或者运行的)放到前台或者后台运行(任意时候只有至多一个前台进程在运行）。最重要的还是创建子进程前后需要屏蔽掉sigchld信号，否则会发生竞争现象。函数的实现方面有evalute对用户输入的命令进行解析，看进程运行的是否是系统自带的命令或是运行程序的命令。对于将前台进程挂起
